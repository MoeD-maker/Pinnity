Find why POST /api/v1/auth/login returns 403 Permission denied and fix it so:

Wrong password → 401

Correct password → 200 + session cookie

No manual DB edits

Step 1 — Trace the route and middleware

In server/index.ts, show where /api/v1/auth/login is mounted. Paste the import and the line where it’s attached.

Print the exact middleware stack for that route: CSRF, rate limit, auth guard, etc. The login route must not require prior auth.

Add temporary logs at the top of the login handler:

ts
Copy
Edit
console.info("[LOGIN] handler hit");
and right before returning 200:

ts
Copy
Edit
console.info("[LOGIN] success", email);
Step 2 — Identify the 403 source

Wrap the body of the login handler with a try/catch that logs the real error and stack:

ts
Copy
Edit
} catch (err:any) {
  console.error("[LOGIN] error", { name: err.name, msg: err.message, code: err.code, stack: err.stack });
  // rethrow mapped error
}
Reproduce the login using the fresh email. Paste the server log for the thrown error.

If the message contains “permission denied for table …” or Postgres error 42501, it’s RLS/policy.

If it’s thrown by a middleware, show which one.

Step 3 — Fix the DB access for login
Assuming you fetch the user by email from your own users/profiles table:

Ensure the DB client used by the server has rights to SELECT email, id, password_hash during login. Options:

Use a service role connection for server-side auth operations, or

Add a read policy for unauthenticated login selector that allows:

sql
Copy
Edit
CREATE POLICY login_lookup ON users
FOR SELECT
TO app_anon
USING (true)  -- only expose minimal columns via SELECT list in the query
and restrict the query to SELECT id, email, password_hash FROM users WHERE lower(email)=lower($1) LIMIT 1;

Do not expose more columns than necessary.

Step 4 — Fix the middleware order

Ensure /api/v1/auth/login is not behind any auth-required guard.

Keep CSRF and rate limit. Rate limit should return 429, not 403.

Step 5 — Normalize and compare

Normalize email: email.trim().toLowerCase()

Hashing: signup uses bcrypt.hash(pw, 12) and login uses bcrypt.compare(pw, hash)

On mismatch, return 401 with a generic message.

Step 6 — Black-box proof

Restart server.

Login with the same email created in your last signup. Provide:

Server logs: [LOGIN] handler hit → [LOGIN] success <email>

Network: POST /api/v1/auth/login → 200 with Set-Cookie

Try wrong password once. Expect 401.

Show the query you use to fetch the user and confirm only the necessary columns are read.

Cleanup

Remove the temporary [LOGIN] error logs after proof.

